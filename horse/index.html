<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Horse Runner</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        canvas {
            background: #f0f0f0;
            display: block;
        }
    </style>
</head>

<body>
    <canvas id="gameCanvas"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let horse = {
            x: 250,
            y: 0,
            width: 100,
            height: 100,
            jumping: true,
            velocityY: 1
        };

        let lives = 3;
        let score = 0;
        let carrotsCollected = 0;
        let platforms = [];
        let carrots = [];
        let platformWidth = 100;
        let platformHeight = 20;
        let scrollSpeed = 3;
        const jumpHeight = 18;
        let lastTime = 0;

        let groundPlatform = {
            x: 0,
            y: canvas.height - 50,
            width: canvas.width,
            height: 50,
            color: 'green'
        };

        let cacti = [];

        function createPlatform(x, y) {
            let p = {
                x: x,
                y: y || Math.random() * (canvas.height - 200 - groundPlatform.height) + 100,
                width: Math.random() * 120 + 60,
                height: platformHeight
            };
            platforms.push(p);
            if (Math.random() > 0.7) {
                createCactus(p.x + Math.random() * (p.width - 50), p.y - 50);
            }
            if (Math.random() > 0.5) {
                createCarrot(p.x + p.width / 2, p.y - 30); // Carrots are placed in the middle of platforms
            }
        }

        function createCactus(x, y) {
            let size = Math.random() * (50 - 30) + 30;
            cacti.push({ x, y, size });
        }

        function createCarrot(x, y) {
            let size = 25; // Fixed size for carrots
            carrots.push({ x, y, size });
        }

        function drawHorse() {
            ctx.font = "100px Arial";
            ctx.textBaseline = 'bottom';
            ctx.fillText("üêé", horse.x, horse.y + horse.height);
        }

        function drawPlatforms() {
            platforms.forEach(p => {
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(p.x, p.y, p.width, p.height);
            });
            ctx.fillStyle = groundPlatform.color;
            ctx.fillRect(groundPlatform.x, groundPlatform.y, groundPlatform.width, groundPlatform.height);
        }

        function drawCacti() {
            cacti.forEach(c => {
                ctx.font = `${c.size}px Arial`;
                ctx.fillText("üåµ", c.x, c.y + c.size);
            });
        }

        function drawCarrots() {
            carrots.forEach(carrot => {
                ctx.font = `${carrot.size}px Arial`;
                ctx.fillText("ü•ï", carrot.x, carrot.y + carrot.size);
            });
        }

        function drawLives() {
            ctx.font = "30px Arial";
            ctx.textAlign = 'right';
            ctx.fillText("‚ù§Ô∏è".repeat(lives), canvas.width - 30, 40);
        }

        function drawScore() {
            ctx.font = "30px Arial";
            ctx.textAlign = 'left';
            ctx.fillText(`Score: ${score}`, 30, 40);
        }

        function jump() {
            if (horse.jumping) return;
            horse.velocityY = -jumpHeight;
            horse.jumping = true;
        }

        canvas.addEventListener('mousedown', function (event) {
            const rect = canvas.getBoundingClientRect(); // Get canvas position and size
            const x = event.clientX - rect.left; // Get x coordinate relative to the canvas

            if (x < canvas.width / 2) {
                shootPoop(); // Left side of the canvas
            } else {
                jump(); // Right side of the canvas
            }
        });

        canvas.addEventListener('touchstart', function (event) {
            const rect = canvas.getBoundingClientRect();
            const touchX = event.touches[0].clientX - rect.left; // Get touch x coordinate relative to the canvas

            event.preventDefault(); // Prevent scrolling and other touch defaults

            if (touchX < canvas.width / 2) {
                shootPoop(); // Left side of the canvas
            } else {
                jump(); // Right side of the canvas
            }
        }, { passive: false }); // Set passive to false to enable preventDefault

        function initPlatforms() {
            let x = 0;
            while (x < canvas.width + 300) {
                createPlatform(x);
                x += Math.random() * 300 + 150;
            }
            createCactus(groundPlatform.x + 200, groundPlatform.y - 50);
        }

        function drawHUD() {
            const hudX = canvas.width - 20; // Set a margin from the right edge

            // Draw Lives (Hearts)
            ctx.font = "30px Arial";
            ctx.textAlign = 'right';
            ctx.fillText("‚ù§Ô∏è".repeat(lives), hudX, 40);

            // Draw Score
            ctx.font = "20px Arial";
            ctx.fillText(`Score: ${score}`, hudX, 70);

            // Draw Food Counter (Carrots Collected)
            ctx.fillText(`Carrots: ${carrotsCollected}`, hudX, 100);
        }

        // Define a new array to hold poop projectiles
        let poops = [];

        // Function to shoot poop
        function shootPoop() {
            if (carrotsCollected > 0) {
                // Adjust the x position to be slightly behind the horse (mimicking a rear-shot).
                // The y position is set to the middle of the horse's height.
                poops.push({
                    x: horse.x + horse.width - 10,  // Start slightly behind the horse's rear
                    y: horse.y + horse.height / 2, // Middle of the horse height
                    size: 20, // Poop emoji size
                    speed: 10  // Speed of the poop emoji
                });
                carrotsCollected -= 1; // Each shot costs one carrot
            }
        }

        document.addEventListener('keydown', function (event) {
            if (event.code === 'Space') {
                shootPoop();
            }
        });



        function drawPoops() {
            poops.forEach(poop => {
                ctx.font = `${poop.size}px Arial`;
                ctx.fillText("üí©", poop.x, poop.y);
            });
        }

        function updatePoops() {
            for (let i = poops.length - 1; i >= 0; i--) {
                poops[i].x += poops[i].speed;

                // Remove poop if it goes off the canvas
                if (poops[i].x > canvas.width) {
                    poops.splice(i, 1);
                    continue;
                }

                // Check collision with cacti
                for (let j = cacti.length - 1; j >= 0; j--) {
                    if (poops[i].x + poops[i].size > cacti[j].x &&
                        poops[i].x < cacti[j].x + cacti[j].size &&
                        poops[i].y + poops[i].size > cacti[j].y &&
                        poops[i].y < cacti[j].y + cacti[j].size) {
                        cacti.splice(j, 1); // Remove cactus on collision
                        poops.splice(i, 1); // Remove poop after hitting cactus
                        break;
                    }
                }
            }
        }

        function updateGame(time) {
            const deltaTime = (time - lastTime) / 1000;
            lastTime = time;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            platforms.forEach(p => { p.x -= scrollSpeed; });
            cacti.forEach(c => { c.x -= scrollSpeed; });
            carrots.forEach(carrot => { carrot.x -= scrollSpeed; });

            updatePoops();  // Update and move poops
            drawPoops();    // Draw poops on the canvas

            if (platforms[platforms.length - 1].x < canvas.width) {
                createPlatform(canvas.width + Math.random() * 200);
            }

            platforms = platforms.filter(p => p.x + p.width > 0);
            cacti = cacti.filter(c => c.x > -50);
            carrots = carrots.filter(carrot => carrot.x > -50);

            horse.y += horse.velocityY;
            horse.velocityY += 1;

            let onPlatform = false;

            platforms.forEach(p => {
                if (horse.x < p.x + p.width &&
                    horse.x + horse.width > p.x &&
                    horse.y + horse.height > p.y &&
                    horse.y < p.y + p.height &&
                    horse.velocityY >= 0) {
                    horse.jumping = false;
                    horse.midairJumpUsed = false;
                    horse.velocityY = 0;
                    horse.y = p.y - horse.height;
                    onPlatform = true;
                }
            });

            if (!onPlatform && horse.y + horse.height >= groundPlatform.y) {
                horse.y = groundPlatform.y - horse.height;
                horse.jumping = false;
                horse.midairJumpUsed = false;
                horse.velocityY = 0;
            }

            carrots.forEach((carrot, index) => {
                if (horse.x < carrot.x + carrot.size &&
                    horse.x + horse.width > carrot.x &&
                    horse.y < carrot.y + carrot.size &&
                    horse.y + horse.height > carrot.y) {
                    carrots.splice(index, 1);
                    score += 10;
                    carrotsCollected += 1;
                }
            });

            cacti.forEach((cactus, index) => {
                if (horse.x < cactus.x + cactus.size &&
                    horse.x + horse.width > cactus.x &&
                    horse.y < cactus.y + cactus.size &&
                    horse.y + horse.height > cactus.y) {
                    cacti.splice(index, 1);
                    lives -= 1;
                }
            });

            if (lives <= 0) {
                alert('Game Over!');
                return;
            }

            drawHorse();
            drawPlatforms();
            drawCacti();
            drawCarrots();
            drawHUD(); // Call the drawHUD function to update the HUD elements
            requestAnimationFrame(updateGame);
        }

        initPlatforms();
        requestAnimationFrame(updateGame);

        // Function to handle jumping logic
        function jump() {
            if (!horse.jumping) {
                horse.velocityY = -jumpHeight;
                horse.jumping = true;
            } else if (!horse.midairJumpUsed) {
                horse.velocityY = -jumpHeight; // Apply midair jump
                horse.midairJumpUsed = true;
            }
        }

    </script>
</body>

</html>
