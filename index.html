<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Farmar.io feed and tame all animals! - Copyright 2024 Wiktor Swiatkowski skleia.com</title>
    <style>
        body,
        html {
            height: 100%;
            margin: 0;
            overflow: hidden;
        }

        canvas {
            background: #f3d8c7;
            display: block;
            margin: auto;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 2px solid black;
        }
    </style>
</head>

<body>
    <canvas id="gameCanvas"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints;

        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        canvas.width = viewportWidth;
        canvas.height = viewportHeight;

        const mapSize = 2048;

        let mouseX = canvas.width / 2;
        let mouseY = canvas.height / 2;

        const player = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            size: 24,
            maxSize: 100,
            speed: 1.3,
            foodEaten: {},
            totalFoodEaten: 0,
            totalFoodPossessed: 0
        };

        const staticObjects = [
            { type: 'rock', emoji: 'ü™®', positions: [], sizeRange: [24, 36, 48] },
            { type: 'tree', emoji: 'üå≥', positions: [], sizeRange: [140, 180, 200] },
            { type: 'mushroom', emoji: 'üçÑ', positions: [], sizeRange: [30, 45, 60] }
        ];

        const foodTypes = {
            "banana": "üçå",
            "peanut": "ü•ú",
            "strawberry": "üçì",
            "carrot": "ü•ï",
            "lettuce": "ü•¨",
            "grass": "üåæ"
        };

        const foodItems = [];
        const foodProjectiles = [];

        const animalsData = {
            "monkey": { "emoji": "üêí", "favoriteFood": ["banana", "peanut"], "sizeRange": [64, 70, 48] },
            "squirrel": { "emoji": "üêøÔ∏è", "favoriteFood": ["peanut", "strawberry"], "sizeRange": [64, 70, 48] },
            "bird": { "emoji": "üê¶", "favoriteFood": ["grass", "strawberry"], "sizeRange": [64, 70, 48] },
            "rabbit": { "emoji": "üêá", "favoriteFood": ["carrot", "strawberry"], "sizeRange": [64, 70, 48] },
            "turtle": { "emoji": "üê¢", "favoriteFood": ["lettuce", "carrot"], "sizeRange": [64, 70, 48] },
            "goat": { "emoji": "üêê", "favoriteFood": ["lettuce", "grass"], "sizeRange": [64, 36, 48] }
        };

        const animals = [];

        function generateBackgroundElements() {
            const squareSize = 500;
            const squaresX = Math.ceil(mapSize / squareSize);
            const squaresY = Math.ceil(mapSize / squareSize);

            for (let x = 0; x < squaresX; x++) {
                for (let y = 0; y < squaresY; y++) {
                    const elementsCount = Math.floor(Math.random() * 3) + 1;
                    for (let i = 0; i < elementsCount; i++) {
                        const objectType = Math.random() > 0.5 ? staticObjects[0] : staticObjects[1];
                        const randomSize = objectType.sizeRange[Math.floor(Math.random() * objectType.sizeRange.length)];
                        objectType.positions.push({
                            x: x * squareSize + Math.random() * squareSize,
                            y: y * squareSize + Math.random() * squareSize,
                            size: randomSize
                        });
                    }
                }
            }
        }

        function generateFoodItems() {
            const squareSize = 500;
            const squaresX = Math.ceil(mapSize / squareSize);
            const squaresY = Math.ceil(mapSize / squareSize);
            const minFoodPerType = 20;
            const maxFoodPerType = 30;

            Object.keys(foodTypes).forEach(type => {
                const amount = Math.floor(Math.random() * (maxFoodPerType - minFoodPerType + 1) + minFoodPerType);
                for (let i = 0; i < amount; i++) {
                    const xSquare = Math.floor(Math.random() * squaresX);
                    const ySquare = Math.floor(Math.random() * squaresY);
                    foodItems.push({
                        type: type,
                        x: xSquare * squareSize + Math.random() * squareSize,
                        y: ySquare * squareSize + Math.random() * squareSize
                    });
                }
            });
        }

        function generateAnimals() {
            const squareSize = 500;
            const squaresX = Math.ceil(mapSize / squareSize);
            squaresY = Math.ceil(mapSize / squareSize);
            const minAnimalsPerType = 1;
            maxAnimalsPerType = 5;

            Object.keys(animalsData).forEach(type => {
                const amount = Math.floor(Math.random() * (maxAnimalsPerType - minAnimalsPerType + 1) + minAnimalsPerType);
                for (let i = 0; i < amount; i++) {
                    const xSquare = Math.floor(Math.random() * squaresX);
                    const ySquare = Math.floor(Math.random() * squaresY);
                    const size = animalsData[type].sizeRange[Math.floor(Math.random() * animalsData[type].sizeRange.length)];
                    animals.push({
                        type: type,
                        emoji: animalsData[type].emoji,
                        x: xSquare * squareSize + Math.random() * squareSize,
                        y: ySquare * squareSize + Math.random() * squareSize,
                        size: size,
                        currentSize: size,
                        maxSize: 100,
                        totalFoodEaten: 0,
                        timesFed: 0,
                        tameStatus: false
                    });
                }
            });
        }

        function drawEntities() {
            staticObjects.forEach(obj => {
                obj.positions.forEach(pos => {
                    ctx.font = `${pos.size}px Arial`;
                    ctx.fillText(obj.emoji, pos.x - player.x + canvas.width / 2, pos.y - player.y + canvas.height / 2);
                });
            });

            ctx.font = '34px Arial'; //food size
            foodItems.forEach(item => {
                const emoji = foodTypes[item.type];
                ctx.fillText(emoji, item.x - player.x + canvas.width / 2, item.y - player.y + canvas.height / 2);
            });

            animals.forEach(animal => {
                ctx.font = `${animal.size}px Arial`;
                ctx.fillText(animal.emoji, animal.x - player.x + canvas.width / 2, animal.y - player.y + canvas.height / 2);
            });
        }

        function drawPlayer() {
            ctx.font = `${player.size}px Arial`; // Use the dynamic size for the player
            ctx.fillText('üòÄ', canvas.width / 2 - player.size / 4, canvas.height / 2 + player.size / 4);
        }


        function updatePlayerSize() {
            // Calculate new size based on the total food possessed
            player.size = 24 + player.totalFoodPossessed; // Starting size is 24, adjust as necessary
            if (player.size > player.maxSize) {
                player.size = player.maxSize; // Ensure player size does not exceed maxSize
            }
        }


        function collect(eater) {
            for (let i = foodItems.length - 1; i >= 0; i--) {
                let food = foodItems[i];
                let dx = eater.x - food.x;
                let dy = eater.y - food.y;
                let distance = Math.sqrt(dx * dx + dy * dy);
                let collectDistance = eater.size;

                if (distance <= collectDistance) {
                    eater.totalFoodEaten++;
                    eater.totalFoodPossessed++;
                    foodItems.splice(i, 1);
                }
            }
        }

        function shootFood() {
            if (player.totalFoodPossessed > 0) { // Ensure the player has food to shoot
                const foodTypeKeys = Object.keys(foodTypes);
                const randomIndex = Math.floor(Math.random() * foodTypeKeys.length);
                const randomFoodType = foodTypeKeys[randomIndex];

                const foodProjectile = {
                    x: player.x,
                    y: player.y,
                    speed: 10,
                    direction: Math.atan2(mouseY - canvas.height / 2, mouseX - canvas.width / 2),
                    foodType: randomFoodType
                };
                foodProjectiles.push(foodProjectile);
                player.totalFoodPossessed--; // Decrease food count when shooting
            } else {
                console.log("No food to shoot!");
            }
        }


        function updateFoodProjectiles() {
            for (let i = foodProjectiles.length - 1; i >= 0; i--) {
                const projectile = foodProjectiles[i];
                projectile.x += Math.cos(projectile.direction) * projectile.speed;
                projectile.y += Math.sin(projectile.direction) * projectile.speed;

                animals.forEach(animal => {
                    if (Math.hypot(projectile.x - animal.x, projectile.y - animal.y) < animal.size) {
                        if (animalsData[animal.type].favoriteFood.includes(projectile.foodType)) {
                            animal.timesFed++;
                            if (animal.timesFed >= 2 && !animal.tameStatus) {
                                animal.tameStatus = true;
                                animal.followingPlayer = true;
                                console.log(`Animal tamed: ${animal.type} now following player.`);
                            }
                            foodProjectiles.splice(i, 1);
                        }
                    }
                });

                if (projectile.x < 0 || projectile.x > mapSize || projectile.y < 0 || projectile.y > mapSize) {
                    foodProjectiles.splice(i, 1);
                }
            }
        }

        function drawFoodProjectiles() {
            ctx.font = '24px Arial';
            ctx.fillStyle = 'red';
            foodProjectiles.forEach(projectile => {
                const emoji = foodTypes[projectile.foodType];
                ctx.fillText(emoji, projectile.x - player.x + canvas.width / 2, projectile.y - player.y + canvas.height / 2);
            });
        }

        function updatePositions() {
            let angle = Math.atan2(mouseY - canvas.height / 2, mouseX - canvas.width / 2);
            let dx = Math.cos(angle) * player.speed;
            let dy = Math.sin(angle) * player.speed;

            staticObjects.forEach(obj => {
                obj.positions.forEach(pos => {
                    pos.x = (pos.x - dx + mapSize) % mapSize;
                    pos.y = (pos.y - dy + mapSize) % mapSize;
                });
            });

            foodItems.forEach(item => {
                item.x = (item.x - dx + mapSize) % mapSize;
                item.y = (item.y - dy + mapSize) % mapSize;
            });

            animals.forEach(animal => {
                if (animal.followingPlayer) {
                    let animalAngle = Math.atan2(player.y - animal.y, player.x - animal.x);
                    animal.x += Math.cos(animalAngle) * animal.speed;
                    animal.y += Math.sin(animalAngle) * animal.speed;
                } else {
                    animal.x = (animal.x - dx + mapSize) % mapSize;
                    animal.y = (animal.y - dy + mapSize) % mapSize;
                }
            });

            player.x = (player.x + dx + mapSize) % mapSize;
            player.y = (player.y + dy + mapSize) % mapSize;

            collect(player);
            animals.forEach(animal => collect(animal));
        }

        function getAnimalStats() {
            const stats = {};
            Object.keys(animalsData).forEach(type => {
                stats[type] = { total: 0, tamed: 0 };
            });

            animals.forEach(animal => {
                stats[animal.type].total++;
                if (animal.tameStatus) {
                    stats[animal.type].tamed++;
                }
            });

            return stats;
        }


        function drawHUD() {
            const stats = getAnimalStats(); // Get the updated stats for all animals
            const hudX = 10; // Position of HUD from left
            const hudY = 10; // Position of HUD from top
            let offsetY = 0;
            const lineHeight = 20; // Line height for each animal type

            ctx.fillStyle = 'rgba(255, 255, 255, 0.75)'; // Semi-transparent white background
            ctx.fillRect(hudX, hudY, 100, Object.keys(stats).length * lineHeight + 60);

            ctx.fillStyle = 'black'; // Text color
            ctx.font = '16px Arial';
            ctx.fillText(`Points: ${player.totalFoodEaten}`, hudX + 10, hudY + 20); ctx.fillText(`Food: ${player.totalFoodPossessed}`, hudX + 10, hudY + 40);

            // Display each animal type with total and tamed numbers
            Object.keys(stats).forEach(type => {
                const info = stats[type];
                ctx.fillText(`${animalsData[type].emoji} ${info.tamed} of ${info.total}`, hudX + 10, hudY + 60 + offsetY);
                offsetY += lineHeight;
            });
        }


        function checkAllAnimalsTamed() {
            return animals.every(animal => animal.tameStatus === true);
        }

        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            updatePositions();

            updatePlayerSize(); // Update the player size based on food possessed
            updateFoodProjectiles();
            drawFoodProjectiles();

            drawEntities();
            drawPlayer();
            drawHUD();
            if (checkAllAnimalsTamed()) {
                drawCongratulations();
            }
            requestAnimationFrame(gameLoop);
        }

        function drawCongratulations() {
            ctx.font = '56px Arial';
            ctx.fillStyle = 'red';
            ctx.textAlign = 'center';
            ctx.fillText('CONGLATURATIONS!!1', canvas.width / 2, canvas.height / 2);
        }

        // Event handling for touch devices
        canvas.addEventListener('mousemove', function (event) {
            if (!isTouchDevice) {
                mouseX = event.clientX;
                mouseY = event.clientY;
            }
        });

        canvas.addEventListener('click', function (event) {
            if (!isTouchDevice) {
                shootFood(); // Shoot food when the mouse is clicked
            }
        });

        // Touch events
        canvas.addEventListener('touchstart', function (event) {
            const touch = event.touches[0];
            const touchX = touch.clientX;
            const touchY = touch.clientY;
            mouseX = touchX;
            mouseY = touchY;
            shootFood(); // Enable shooting food with a touch
            event.preventDefault(); // Prevent scrolling when touching canvas
        }, false);

        canvas.addEventListener('touchmove', function (event) {
            const touch = event.touches[0];
            mouseX = touch.clientX;
            mouseY = touch.clientY;
            event.preventDefault(); // Prevent scrolling when dragging on canvas
        }, false);

        generateBackgroundElements();
        generateFoodItems();
        generateAnimals();
        gameLoop();
    </script>
</body>

</html>
